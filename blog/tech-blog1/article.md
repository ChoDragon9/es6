# 신규 프로젝트 할 때 알면 좋을 소소한 팁

## 들어가며
이번에 제가 전달하고 싶은 이야기는 신규 프로젝트를 할 때 알면 좋을 소소한 팁입니다.

저는 올해 9월부터 신규 프로젝트를 진행하게 되었습니다. 현재는 개발 막바지 상황이고 릴리즈를 앞두고 있습니다. 이번에 신규 프로젝트를 하며 지금까지 쌓았던 경험을 더불어서 정리하게 되었습니다. 신규 프로젝트를 할 예정이거나 하고 있는 분들에게 소소한 팁이 되었으면 합니다.

이 글은 프로젝트 초기 단계부터 구현까지에 대한 내용입니다. 개발에 초점을 둔 내용이고, 일정관리나 위험관리처럼 관리에 속하는 이야기는 다음에 이야기를 드리고 싶습니다.

이 글의 순서를 이렇게 진행됩니다.

## 목차
- [꼼꼼하게 요구사항 분석 하기](#꼼꼼하게-요구사항-분석-하기)
- [도면 그리기](#도면-그리기)
- [벽돌 정하기](#벽돌-정하기)
- [벽돌 조립 가이드 라인](#벽돌-조립-가이드-라인)

## 꼼꼼하게 요구사항 분석 하기
### 서론 

> 요구사항은 개발 초기에 반영되어야 만족하는 시스템을 개발할 수 있다. 요구사항이 누락되어 시스템 개발 과정에 도출된다면 전체 구조가 흔들릴 가능성이 매우 높다. 현실은 요구사항에 대한 누락이 자주 발생하고 관심이 부족하다. 아키텍처 설계를 제대로 하려면 요구사항 개발에 주목해야 한다.
>
> - 오병곤. 『실용주의 소프트웨어 개발』. 로드북, 2017.

저는 개발 초기에 요구사항을 꼼꼼하게 분석하고 기록합니다. 이렇게 분석된 요구사항은 구조 설계에 반영되고, 커뮤니케이션 단계에서 협의할 주제가 되기 때문입니다. 뿐만 아니라 꼼꼼하게 분석된 요구사항을 통해 보완이 필요한 요구사항이나 일정상 구현하기 힘든 부분을 식별하고 담당자와 협의를 진행할 수 있기 때문입니다.

### 정보

제가 주로 사용하는 요구사항을 분석하는 방법은 사용자 스토리와 기능 리스트를 작성하는 것입니다.

먼저 사용자 스토리에 대한 설명을 드리겠습니다.

#### 사용자 스토리

사용자 스토리는 기획서에 표현된 기능을 사용자 입장에서 작성한 기능의 사용방법입니다. 작성 형식은 `~하면 ~할 수 있다` 와 같은 형식으로 **어디**, **무엇**을 하는지 정의하며, 하나의 기능만을 표현합니다.

사용자 스토리를 작성하는 데 주의할 점이 있습니다. 사용자 입장에서 기획서를 왼쪽에서 오른쪽 방향으로 위에서 아래 방향으로 보면서 각각의 사용자 스토리를 작성해야 합니다. 그리고 기존에 있던 기능이라도 일단 작성하는 것이 좋습니다. 결과적으로 기획서 대신 사용자 스토리로 기능을 파악할 수 있습니다.

##### [예시 1.1] 사용자 스토리 예시

```
- [US] 결제하기 버튼을 클릭하면 결제 페이지로 이동할 수 있다.
- [US] 결제 페이지 접근 시 제품 이름, 가격, 배송지, 약관 동의하기 체크박스를 볼 수 있다.
```

#### 기능 리스트

기능 리스트는 구현할 기능을 나열하는 것입니다. 기능 리스트는 사용자 스토리를 기반하고 하나의 사용자 스토리를 충족하기 위해 구현해야 할 기능을 모두 나열합니다. 작성 형식은 `[담당] 작업 내용` 형식으로 작성합니다.

마지막으로 재사용할 수 있는 기능들을 그룹을 만듭니다. 그룹을 만들게 되면 재사용 코드의 식별을 할 수 있고, 어떻게 추상화할지 판단할 수 있기 때문입니다.

##### [예시 1.2] 기능 리스트 예시

```
- [US] 결제하기 버튼을 클릭하면 결제 페이지로 이동할 수 있다.
  - [마크업] 결제 페이지 마크업
  - [프런트] 결제 페이지 마크업 작업
  - [프런트] 페이지 이동 링크 작업
- [US] 결제 페이지 접근 시 제품 이름, 가격, 배송지, 약관 동의하기 체크박스를 볼 수 있다.
  - [API] 제품 조회 API
  - [프런트] 제품 조회 API 연동
```




## 도면 그리기
### 서론

> 아키텍처 설계는 개발 이전에 선행해서 진행해야 한다. 프로젝트 초기 단계부터 각 시스템 이해관계자와 긴밀한 소통을 통해 아키텍처 구조를 만들어가야 한다. 아키텍처 설계와 관련해서 가장 큰 이슈는 아직도 아키텍처 설계 필요성에 대한 인식과 아키텍처 설계 방법에 대한 이해가 부족하다는 것이다.
>
> - 오병곤. 『실용주의 소프트웨어 개발』. 로드북, 2017.

저는 구현에 들어가기 앞서 구조 설계를 진행합니다. 구조 설계의 목적은 개발에 투입되는 비용을 최소화하고 유지 보수하는 데 비용을 지속적으로 낮게 유지하기 위해서입니다. 이번 주제에서는 어떤 사상과 원칙으로 설계를 진행했는지 소개합니다.

### 정보

#### 사상

> 패러다임은 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용할지를 결정한다.
>
> 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는 지를 말해준다.
>
> - 로버트 C. 마틴.  『클린 아키텍처』. 송준이(역). 인사이트, 2019.

저는 구조 설계 시 첫 번째로 프로그래밍 패러다임을 결정합니다. 

프로그래밍 패러다임은 무엇을 해야 하는지 보다 무엇을 하지 말아야 되는지 말해줍니다. 그리고 프로그래밍 패러다임에 따라 구조를 결정하게 됩니다. 

프로그래밍 패러다임은 대표적으로 절차형, 객체지향, 함수형 가 있는 데, 저는 함수형과 객체지향의 사상을 따르고 있습니다. 

먼저 함수형에서 추구하는 것은 가변을 멀리하고 불변을 추구하는 것입니다. 경합 조건, 교착상태 조건, 동시성 업데이트 문제가 모두 가변 변수로 인해 발생하기 때문에 가변성에 대한 염려로 불변을 추구합니다. 

그리고 객체지향에서 추구하는 것은 의존성 역전을 통한 제어 흐름과 의존성 방향을 역전시켜 의존성에 대한 제어권을 가지는 것입니다. 즉, 소스 코드 의존성이 제어 흐름의 방향과 일치되도록 제한되지 않게 할 수 있는 것입니다.

##### [사례 2.1] Nuxt 구조 설계 사례

Nuxt에서 제공하는 폴더 구조에서 추가적으로 구조를 설계한 사례입니다.

불변, 가변 컴포넌트를 구분하고, 불변 로직을 담을 수 있는 공간을 만들었습니다. 그리고 인터페이스를 통한 의존성 역전을 위해 인터페이스를 정의하는 공간을 만들었습니다.

###### 패러다임에 영향받은 폴더 구조

- layouts: 가변 레이아웃 컴포넌트
- pages: 가변 페이지 컴포넌트
- components/pages: pages에 사용할 가변 컴포넌트
- components/atomic-design: Atomic Design을 따르는 불변 컴포넌트
- components/etc: pages에 사용할 불변 컴포넌트
- plugins: 불변 함수 및 클래스
- types: 인터페이스 정의

```
├─ layouts
├─ pages
├─ components
│  ├─ pages
│  ├─ atomic-design
│  └─ etc
├─ plugins
└─ types
```

#### 관심 분리

> 관심이란 소프트웨어의 기능이나 목적을 뜻한다. 관심을 분리한다는 것은 각각의 관심에 관련된 코드를 모아 독립된 모듈로 만들어 다른 코드로부터 분리한다는 뜻이다. 설계 기법에서 패턴의 대부분은 관심의 분리를 실현하려는 목표를 가지고 있다. 가장 대표적인 패턴이 MVC 패턴이다. MVC 패턴에서는 비즈니스 로직, 사용자에 대한 표시, 입력 처리를 분리한다.
>
> - 우에다 이사오. 『프로그래밍의 정석』. 류두진(역). 프리렉, 2017.

저는 기능이나 목적별로 관심을 분리해서 폴더로 공간을 만듭니다.

관심을 분리하는 작업은 프로젝트를 세팅할 때마다 항상 새롭게 다가왔습니다. 그래서 지속적으로 관리하고 누락을 방지하기 위해서 체크 리스트가 필요하다고 느꼈습니다.

##### 아키텍처 체크 리스트

아래 항목들은 아키텍처 체크 리스트입니다. 필수적으로 필요한 사항도 있고, 선택적인 사항이 있습니다. 프로젝트에 필요한 부분인데 누락된 부분이 있다면 추가하는 것을 권합니다.

```
1. 컴파일되지 않은 에셋들을 포함하는 구성요소가 있는가?
2. 정적 파일들을 포함하는 구성요소가 있는가?
3. 페이지나 컴포넌트에 접근하기 전에 실행할 사용자 정의 함수를 정의하는 구성요소가 있는가?
4. 라우터를 정의하는 구성요소가 있는가?
5. 상태 관리를 하는 구성요소가 있는가?
6. 외부 라이브러리를 애플리케이션에 사용하도록 연결하는 구성요소가 있는가?
7. 상수를 정의하는 구성요소가 있는가?
8. 컴포넌트를 포함하는 구성요소가 있는가?
9. 컴포넌트 볼륨을 줄일 수 있는 구성요소가 있는가?
10. 페이지 단위를 분리할 수 있는 구성요소가 있는가?
11. 프로젝트 환경 설정을 포함하는 구성요소가 있는가?
12. 테스트 파일들을 포함하는 구성요소가 있는가?
```

##### [사례 2.2] Angular에 아키텍처 체크 리스트 적용 사례

###### 항목 별 폴더

```
1. [assets] 컴파일되지 않은 에셋들을 포함하는 구성요소가 있는가?
2. [assets] 정적 파일들을 포함하는 구성요소가 있는가?
3. [guards] 페이지나 컴포넌트에 접근하기 전에 실행할 사용자 정의 함수를 정의하는 구성요소가 있는가?
4. [app.routing.ts] 라우터를 정의하는 구성요소가 있는가?
5. [states, *.state.ts] 상태 관리를 하는 구성요소가 있는가?
6. [*.helper.ts] 외부 라이브러리를 애플리케이션에 사용하도록 연결하는 구성요소가 있는가?
7. [constants] 상수를 정의하는 구성요소가 있는가?
8. [shared/components, modules] 컴포넌트를 포함하는 구성요소가 있는가?
9. [helper, pipe, directive] 컴포넌트 볼륨을 줄일 수 있는 구성요소가 있는가?
10. [feature.module.ts] 페이지 단위를 분리할 수 있는 구성요소가 있는가?
11. [src/enviroments] 프로젝트 환경 설정을 포함하는 구성요소가 있는가?
12. [e2e/src, *.spec.ts] 테스트 파일들을 포함하는 구성요소가 있는가?
```

###### 폴더 구조

```
├─ e2e
│  └─ src
├─ src
│  ├─ app
│  │  ├─ app.module.ts
│  │  ├─ app.routing.ts
│  │  ├─ constants
│  │  ├─ modules
│  │  │  └─ feature
│  │  │     ├─ feature.module.ts
│  │  │     ├─ feature.page.ts
│  │  │     ├─ feature.page.html
│  │  │     ├─ pipes
│  │  │     ├─ directives
│  │  │     ├─ shared
│  │  │     │  ├─ feature.helper.ts
│  │  │     │  ├─ feature.state.ts
│  │  │     │  └─ child.state.ts
│  │  │     └─ components
│  │  │        ├─ child.ts
│  │  │        ├─ child.html
│  │  │        ├─ child2
│  │  │        ├─ child2.spec.ts
│  │  │        ├─ child2.ts
│  │  │        └─ child2.html
│  │  ├─ core
│  │  │  ├─ core.module.ts
│  │  │  ├─ apis
│  │  │  ├─ guards
│  │  │  ├─ helpers
│  │  │  └─ states
│  │  └─ shared
│  │     ├─ shared.module.ts
│  │     ├─ components
│  │     ├─ directives
│  │     └─ pipes
│  ├─ assets
│  └─ environments
```

## 벽돌 정하기
### 서론

> 모든 프로그램은 순차 / 분기 / 반복이라는 세 가지 구조만으로도 표현할 수 있다.
>
> - 로버트 C. 마틴.  『클린 아키텍처』. 송준이(역). 인사이트, 2019.

제가 구현하는 코드에는 대부분 순차, 분기, 반복으로 이루어져 있습니다. 그리고 비교 연산, 자료 구조 분해 및 할당과 같은 빈번하게 사용되는 요소들이 존재합니다. 이러한 구현 요소들이 코드에 작성될 때마다 다르게 작성되어 있으면 이해하기 힘들거라 생각했습니다. 불규칙적인 코드를 미연에 방지하고자 구현 방법의 룰을 작성했습니다.

### 정보

구현 방법은 프로그래밍 패러다임에 많은 영향을 미친다고 생각합니다. 이 사례는 불변성을 추구하는 상황에서 작성한 룰입니다.

#### 선언형 함수 사용

> 선언형의 표현이란 코드의 의도를 전하고자 할 때 가능한 명령형보다는 선언형으로 표현하는 것을 뜻한다. 명령형 프로그래밍은 문제의 해법, 즉 자료구조와 알고리즘을 기술한다. 반면에 선언형 프로그래밍은 문제의 정의, 즉 해결해야 할 문제의 성질이나 이때 충족해야 할 제약을 기술한다.
>
> - 우에다 이사오. 『프로그래밍의 정석』. 류두진(역). 프리렉, 2017.

선언형 함수는 해결할 문제를 기술한 함수입니다. 자바스크립트 문법을 사용하여 로직을 기술하기보다는 함수명을 통해 로직을 기술합니다.

선언형 함수를 사용하면 중복 요소들을 식별하기 쉽고, 재사용성이 높기 때문에 선언형 함수를 사용하는 것을 선호하고 있습니다.

##### [예 3.1] Array#map 함수

최근 들어 자주 사용되는 것으로 보이는 것은 Array의 메서드입니다. 그중에 `map` 을 예를 들면 이러한 명령형 코드를 대체할 수 있습니다.

```js
// 명령형
const arr = [1, 2, 3]
for (let i = 0; i < arr.length; i++) {
  arr[i] = arr[i] * 10
}
console.log(arr)
// [10, 20, 30]

// 선언형
[1, 2, 3].map(v => v * 10)
// [10, 20, 30]
```

#### 순차
- 비동기는 `async/await` 를 사용하여 동기식으로 기술합니다.
  - 콜백 패턴을 사용하지 않는 이유는 비동기 흐름을 비선형적, 비순차적인 방향으로 나타내며, 호출의 제어권을 암시적으로 넘겨줘야 하기 때문입니다.
- 에러 처리는 `try/catch`를 사용하지 않고, `then` 또는 `catch`를 사용합니다.
  - 함수 정의부에서 `try/catch` 를 사용하여 에러 처리의 예측이 어려운 경우가 생깁니다.
  - 함수 정의부가 아닌 함수 사용부에서 에러 처리를 하여, 에러 처리가 예측 가능한 게 이해하기 쉽다는 것을 경험했기 때문입니다.

##### [예 3.2] 비동기 순차 처리 예시

```js
// 함수 정의부
async function foo() {
  const a = await new Promise((resolve) => {
    setTimeout(resolve, 1000)
  })
  const b = await Promise.reject('에러 발생!');
  return `${a}${b}`;
}

// 함수 사용부
foo().catch(console.log) // 에러 발생!
```

#### 분기
- 분기는 `if/else` 를 멀리하고 삼항 연산자를 사용합니다.
  - `if/else`는 문(statement)이기 때문에 강제성을 띄지 않습니다.
  - 삼항 연산자는 식(expression)이기 때문에 강제성을 띄기 때문에 사용합니다.
- `!`는 선언형 함수인  `not` 함수 사용합니다.
  - `!value` 이런 형태로 사용하던 코드를  `not(value)` 으로 사용합니다.
- `!!`는 선언형 함수인 `toBool` 함수 사용합니다.
  - `!!value` 이런 형태로 사용하던 코드를  `toBool(value)` 으로 사용합니다.

##### [예 3.3] 분기 예시

```js
// 공통 함수
const toBool = v => !!v
const not = v => !v

// 함수 정의
const mapName = (arr) => {
  return toBool(arr) ? 
    arr.map(({name}) => name) : 
    []
}
const filterOffline = arr => {
  return toBool(arr) ? 
    arr.filter(({online}) => not(online)) : 
    []
}

// 함수 사용
mapName(filterOffline()) // []

mapName(filterOffline([
  {name: 'A', online: false},
  {name: 'B', online: true}
])) // ['A']
```

#### 반복

- `for` `while`을 사용하지 않고,  `map`, `filter` 등과 같은 선언형 함수를 사용합니다.
- 함수 조합을 높게 하기 위해 커링으로 정의합니다.

##### [예 3.4] 반복 사용 예시

```js
// 공통 함수 정의
const filter = pred => iter => iter.filter(pred)
const map = mapper => iter => iter.map(mapper)
const pipe = (fn, ...fns) => (...arg) => {
  return fns.reduce((acc, fn) => fn(acc), fn(...arg))
}

// 함수 사용
const removeInEarth = (_,i) => i%2 === 0
const extractName = ({name}) => name
const fingerSnap = pipe(
  filter(removeInEarth),
  map(extractName)
)
```

#### 비교 연산
- 비교 연산은 `===` 연산자를 사용하지 않고, `isSame` 이름의 선언형 함수를 사용합니다.
- 비교 대상의 동일한 경우 중복을 해결하기 위해 커링으로 정의합니다.

##### [예 3.5] isSame 사용 예시

```js
// 공통 함수 정의
const isSame = src => target => src === target

// 함수 사용
const toEng = num => {
  const isSameNum = isSame(num)
  if (isSameNum(0)) {
    return 'A'
  }
  if (isSameNum(1)) {
    return 'BB'
  }
  if (isSameNum(2)) {
    return 'CCC'
  }
}

toEng(0) // A
toEng(1) // BB
toEng(2) // CC
```

#### 자료 구조 분해 및 할당

- 객체 분해, 할당 문법을 사용하지 않고 선언형 함수를 사용합니다.
- 객체 분해는 `pick`, `pluck` 함수 사용합니다.
- 객체 할당은 `assign` 함수 사용합니다.

##### [예 3.6] 분해, 할당 함수 사용 예시

```js
// 공통 함수 정의
const pick = (keys, obj) => keys
  .map(key => ({[key]: obj[key]}))
  .reduce((acc, obj) => Object.assign(acc, obj))
const pluck = (keys, obj)=> keys.map(key => obj[key])
const assign = (...objs) => Object.assign(...objs)

// 함수 사용
const obj = {key1: 'value1', key2: 'value2'}

pick(['key1'], obj) // { key1: 'value1' }
pluck(['key1'], obj) // ['value1']

assign({}, {key3: 'value3'}, obj)
// {key1: 'value1', key2: 'value2', key3: 'value3'}
```

## 벽돌 조립 가이드 라인
### 서론

이번 주제에서는 제가 선호하는 개발 원칙 다섯 가지에 대해 소개드리려고 합니다. 아무리 좋은 기술이나 설계가 있어도 정도(程度)를 지키는 게 중요하다고 생각합니다. 이 다섯 가지 원칙들은 개발의 정도(程度)를 지키는 데 많은 도움이 되었습니다. 

이번 주제에서는 구현할 때 참고할 가이드라인을 제시합니다. 사람마다 규모를 측정하는 범위가 다르고 쉽다고 느끼는 부분이 다르기 때문에 구체적인 예시보다는 추상적인 가이드라인을 제시합니다.

### 정보

#### 명명이 중요하다(Naming is important)

적절한 이름을 붙일 수 있었다는 것은 해당 요소가 바르게 이해되고 바르게 설계되어 있다는 뜻입니다. 반대로 어울리지 않는 이름을 붙여졌다는 것은 해당 요소가 달성해야 할 역할에 대해 본인이 충분히 이해하지 못했다는 뜻입니다.

이름은 코드를 통해 개발자끼리 의사소통을 이루어지므로 이름이 적절하지 않으면 코드 상의 대화는 성립하지 않습니다.

#### KISS(Keep It Short and Simple)

코드를 작성할 때는 최우선 가치를 단순성과 간결성에 둡니다. 복잡한 코드는 읽기 어렵고 수정하기 어려워집니다. 프로그래밍 중에 코드가 동작할 수 있는 가장 간단한 방법은 무엇인지 항상 질문을 던져야 합니다.

#### DRY(Don't Repeat Yourself)

똑같은 코드가 여러 군데 있으면 모든 곳을 정확하게 수정하지 않는 이상 전체적으로 정합성을 보장할 수 없습니다. 코드 로직은 함수화, 모듈화 하고, 데이터라면 이름을 붙여 상수를 정의합니다.

사고의 중복은 디자인 패턴을 통해 해결합니다. 같은 문제에 관해 반복해서 해결책을 생각하는 중복을 일어나지 않게 하는 기법이 디자인 패턴입니다.

#### SLAP(Single Level of Abstraction Principle)

코드를 작성할 때 높은 수준의 추상화 개념과 낮은 수준의 추상화 개념을 분리하도록 합니다. 추상화 단계는 상하가 아니라 기능의 복잡도에 따라 여러 계층으로 분리합니다. 결과적으로 추상화 수준을 일치시킨 코드는 훌륭한 책과 같습니다. 최고 수준부터 중간 수준의 처리가 책의 목차가 되고 최저 수준의 처리가 책의 본문 내용이 됩니다.

#### YAGNI(You Aren't Going to Need it)

확장성을 고려해서 넣은 설계라도 예상은 대부분 빗나갑니다. 빗나간다는 것은 거기에 들인 시간이 쓸모없어진다는 뜻입니다. 범용성보다는 단순성을 생각하는 게 좋습니다. 범용성이 가져다주는 재사용성이나 확장성도 좋지만, 그 보다는 우선 사용할 수 있는 데 가치를 두는 것을 권하고 싶습니다.
## 마치며 

지금까지 전달했던 소소한 팁을 요약하면 아래와 같습니다. 

- 요구사항은 초기에 꼼꼼하게 분석돼야 하며, 사용자 스토리와 기능 리스트를 통해 해결할 수 있음 
- 구현전에 설계를 진행해야 하며, 프로그래밍 패러다임과 관심 분리를 통해 해결할 수 있음 
- 전체적인 구현 코드의 통일성을 위해 구현 규칙이 필요하며, 프로그래밍 패러다임에 따라 규칙을 결정됨 
- 구현은 단순하고 간결하게 해야 하며 현재 필요한 부분만 구현해야 함 



신규 프로젝트를 할 때 더욱 도움이 되겠지만 어떠한 부분은 프로젝트는 운영하며 적용할 수 있는 개념입니다. 지금까지 제 나름대로 새운 기준으로 소소한 팁을 전달해봤습니다. 이 기준에 여러분들의 기준의 살을 덧붙여서 좋은 지식이 되었으면 좋겠습니다. 

지금까지 읽어주셔서 감사합니다.