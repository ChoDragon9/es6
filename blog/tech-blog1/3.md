## 도면 그리기
### 서론

> 아키텍처 설계는 개발 이전에 선행해서 진행해야 한다. 프로젝트 초기 단계부터 각 시스템 이해관계자와 긴밀한 소통을 통해 아키텍처 구조를 만들어가야 한다. 아키텍처 설계와 관련해서 가장 큰 이슈는 아직도 아키텍처 설계 필요성에 대한 인식과 아키텍처 설계 방법에 대한 이해가 부족하다는 것이다.
>
> - 오병곤. 『실용주의 소프트웨어 개발』. 로드북, 2017.

저는 구현에 들어가기 앞서 구조 설계를 진행합니다. 구조 설계의 목적은 개발에 투입되는 비용을 최소화하고 유지 보수하는 데 비용을 지속적으로 낮게 유지하기 위해서입니다. 이번 주제에서는 어떤 사상과 원칙으로 설계를 진행했는지 소개합니다.

### 정보

#### 사상

> 패러다임은 어떤 프로그래밍 구조를 사용할지, 그리고 언제 이 구조를 사용할지를 결정한다.
>
> 패러다임은 무엇을 해야 할지를 말하기보다는 무엇을 해서는 안 되는 지를 말해준다.
>
> - 로버트 C. 마틴.  『클린 아키텍처』. 송준이(역). 인사이트, 2019.

저는 구조 설계 시 첫 번째로 프로그래밍 패러다임을 결정합니다. 

프로그래밍 패러다임은 무엇을 해야 하는지 보다 무엇을 하지 말아야 되는지 말해줍니다. 그리고 프로그래밍 패러다임에 따라 구조를 결정하게 됩니다. 

프로그래밍 패러다임은 대표적으로 절차형, 객체지향, 함수형 가 있는 데, 저는 함수형과 객체지향의 사상을 따르고 있습니다. 

먼저 함수형에서 추구하는 것은 가변을 멀리하고 불변을 추구하는 것입니다. 경합 조건, 교착상태 조건, 동시성 업데이트 문제가 모두 가변 변수로 인해 발생하기 때문에 가변성에 대한 염려로 불변을 추구합니다. 

그리고 객체지향에서 추구하는 것은 의존성 역전을 통한 제어 흐름과 의존성 방향을 역전시켜 의존성에 대한 제어권을 가지는 것입니다. 즉, 소스 코드 의존성이 제어 흐름의 방향과 일치되도록 제한되지 않게 할 수 있는 것입니다.

##### [사례 2.1] Nuxt 구조 설계 사례

Nuxt에서 제공하는 폴더 구조에서 추가적으로 구조를 설계한 사례입니다.

불변, 가변 컴포넌트를 구분하고, 불변 로직을 담을 수 있는 공간을 만들었습니다. 그리고 인터페이스를 통한 의존성 역전을 위해 인터페이스를 정의하는 공간을 만들었습니다.

###### 패러다임에 영향받은 폴더 구조

- layouts: 가변 레이아웃 컴포넌트
- pages: 가변 페이지 컴포넌트
- components/pages: pages에 사용할 가변 컴포넌트
- components/atomic-design: Atomic Design을 따르는 불변 컴포넌트
- components/etc: pages에 사용할 불변 컴포넌트
- plugins: 불변 함수 및 클래스
- types: 인터페이스 정의

```
├─ layouts
├─ pages
├─ components
│  ├─ pages
│  ├─ atomic-design
│  └─ etc
├─ plugins
└─ types
```

#### 관심 분리

> 관심이란 소프트웨어의 기능이나 목적을 뜻한다. 관심을 분리한다는 것은 각각의 관심에 관련된 코드를 모아 독립된 모듈로 만들어 다른 코드로부터 분리한다는 뜻이다. 설계 기법에서 패턴의 대부분은 관심의 분리를 실현하려는 목표를 가지고 있다. 가장 대표적인 패턴이 MVC 패턴이다. MVC 패턴에서는 비즈니스 로직, 사용자에 대한 표시, 입력 처리를 분리한다.
>
> - 우에다 이사오. 『프로그래밍의 정석』. 류두진(역). 프리렉, 2017.

저는 기능이나 목적별로 관심을 분리해서 폴더로 공간을 만듭니다.

관심을 분리하는 작업은 프로젝트를 세팅할 때마다 항상 새롭게 다가왔습니다. 그래서 지속적으로 관리하고 누락을 방지하기 위해서 체크 리스트가 필요하다고 느꼈습니다.

##### 아키텍처 체크 리스트

아래 항목들은 아키텍처 체크 리스트입니다. 필수적으로 필요한 사항도 있고, 선택적인 사항이 있습니다. 프로젝트에 필요한 부분인데 누락된 부분이 있다면 추가하는 것을 권합니다.

```
1. 컴파일되지 않은 에셋들을 포함하는 구성요소가 있는가?
2. 정적 파일들을 포함하는 구성요소가 있는가?
3. 페이지나 컴포넌트에 접근하기 전에 실행할 사용자 정의 함수를 정의하는 구성요소가 있는가?
4. 라우터를 정의하는 구성요소가 있는가?
5. 상태 관리를 하는 구성요소가 있는가?
6. 외부 라이브러리를 애플리케이션에 사용하도록 연결하는 구성요소가 있는가?
7. 상수를 정의하는 구성요소가 있는가?
8. 컴포넌트를 포함하는 구성요소가 있는가?
9. 컴포넌트 볼륨을 줄일 수 있는 구성요소가 있는가?
10. 페이지 단위를 분리할 수 있는 구성요소가 있는가?
11. 프로젝트 환경 설정을 포함하는 구성요소가 있는가?
12. 테스트 파일들을 포함하는 구성요소가 있는가?
```

##### [사례 2.2] Angular에 아키텍처 체크 리스트 적용 사례

###### 항목 별 폴더

```
1. [assets] 컴파일되지 않은 에셋들을 포함하는 구성요소가 있는가?
2. [assets] 정적 파일들을 포함하는 구성요소가 있는가?
3. [guards] 페이지나 컴포넌트에 접근하기 전에 실행할 사용자 정의 함수를 정의하는 구성요소가 있는가?
4. [app.routing.ts] 라우터를 정의하는 구성요소가 있는가?
5. [states, *.state.ts] 상태 관리를 하는 구성요소가 있는가?
6. [*.helper.ts] 외부 라이브러리를 애플리케이션에 사용하도록 연결하는 구성요소가 있는가?
7. [constants] 상수를 정의하는 구성요소가 있는가?
8. [shared/components, modules] 컴포넌트를 포함하는 구성요소가 있는가?
9. [helper, pipe, directive] 컴포넌트 볼륨을 줄일 수 있는 구성요소가 있는가?
10. [feature.module.ts] 페이지 단위를 분리할 수 있는 구성요소가 있는가?
11. [src/enviroments] 프로젝트 환경 설정을 포함하는 구성요소가 있는가?
12. [e2e/src, *.spec.ts] 테스트 파일들을 포함하는 구성요소가 있는가?
```

###### 폴더 구조

```
├─ e2e
│  └─ src
├─ src
│  ├─ app
│  │  ├─ app.module.ts
│  │  ├─ app.routing.ts
│  │  ├─ constants
│  │  ├─ modules
│  │  │  └─ feature
│  │  │     ├─ feature.module.ts
│  │  │     ├─ feature.page.ts
│  │  │     ├─ feature.page.html
│  │  │     ├─ pipes
│  │  │     ├─ directives
│  │  │     ├─ shared
│  │  │     │  ├─ feature.helper.ts
│  │  │     │  ├─ feature.state.ts
│  │  │     │  └─ child.state.ts
│  │  │     └─ components
│  │  │        ├─ child.ts
│  │  │        ├─ child.html
│  │  │        ├─ child2
│  │  │        ├─ child2.spec.ts
│  │  │        ├─ child2.ts
│  │  │        └─ child2.html
│  │  ├─ core
│  │  │  ├─ core.module.ts
│  │  │  ├─ apis
│  │  │  ├─ guards
│  │  │  ├─ helpers
│  │  │  └─ states
│  │  └─ shared
│  │     ├─ shared.module.ts
│  │     ├─ components
│  │     ├─ directives
│  │     └─ pipes
│  ├─ assets
│  └─ environments
```
