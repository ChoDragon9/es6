## 주기적으로 검사하기
### 서론

- 완변한 설계는 없다. 개발 할 때 비용이 많이 든다면 설계의 수정이 필요할 때이다. 아래와 같은 사례가 있다.

### 정보

- 어떤 것을 검사해야 하는 가?
- 파일이 부적합한 위치에 있는 데, 현재 구조에서 담을 장소가 없을 때
- 중복된 코드가 있는 데 담을 수 있는 장소가 없을 때
- 코드의 양이 많은 데 구조적인 문제로 해결 가능할 때

### 사례

#### UI 상태관리 설계부족
컴포넌트간의 공유해야할 상태를 부모 컴포넌트를 통해서 하는 경우가 빈번하다. 여기서 설계 오류는 자식 컴포넌트가 외부에 의존성있는 비순수 컴포넌트 임에도 Prop로 사용한 것이다.

비순수 컴포넌트라면 특수화된 컴포넌트인데 순수 컴포넌트를 위한 Prop를 사용하여 복잡성을 유발했다. 즉, Vuex의 State를 통한 UI 상태 공유 정책이 필요하다.

##### 문제점
- Backend API의 State에 UI를 위한 State를 작성하면 관심사가 분리가 되지 않음
  - Backend API의 State는 HTTP Response
  - UI State는 Component의 State

##### 해결 방안
- Vuex에서 Backend API와 UI State를 모듈단위로 선분리함
- Backend API 모듈에는 HTTP 통신을 위함
- UI 모듈에는 View의 상태를 위함

#### Vuex의 Action과 Mutation의 함수명 중복 해결
##### 문제점
Action과 Mutation에서 정의한 함수명이 중복되어도 추적이 되지 않는 다. 매번 검색을 통해서 해결 가능하지만 검색을 하지 않고 변경을 가할 경우 이슈가 발생한다.

##### 해결방안
Action과 Mutation의 함수명을 상수로 정의한다. 상수를 사용하여 정의 및 사용하도록 한다. 해당 방안을 사용하면 nuxt 라이프사이클 중 `fetch`에서도 중복을 해결할 수 있다.

##### 코드
`export default`가 아닌 `export const`로 선언하면 IDE에서 `Add import statement`를 지원받을 수 있다.

###### /auth/action.ts
```ts
export const changeUnauthorizedUser = 'changeUnauthorizedUser'
export const fetchCheckLogin = 'fetchCheckLogin'
```
###### /auth/mutation.ts
```ts
export const mutateAuth = 'mutateAuth'
export const mutateAdmin = 'mutateAdmin'
export const mutateUnauthorizedUser = 'mutateUnauthorizedUser'
```
###### /auth/index.ts
```ts
export * from './action'
export * from './mutation'
```

