## 도면 그리기
### 개요 
### 배경 
### 주장 
### 근거 
### 사례

> [도서 발췌] 실용주의 소프트웨어 개발 > 07 아키텍쳐 설계 절차 및 적용
>> 아키텍처 설계는 개발 이전에 선행해서 진행해야 한다. 프로젝트 초기 단계부터 각 시스템 이해관계자와 긴밀한 소통을 통해 아키텍처 구조를 만들어가야 한다. 아키텍처 설계와 관련해서 가장 큰 이슈는 아직도 아키텍처 설계 필요성에 대한 인식과 아키텍처 설계 방법에 대한 이해가 부족하다는 것이다.

> [도서 발췌] 클린 아키텍처
>> 패러다임이란 프로그래밍을 하는 방법으로, 대체로 언어에는 독립적이다. 패러다임은 어떤 프로그래밍 구조를 사용할 지, 그리고 언제 이 구조를 사용할지를 결정한다.

> [도서 발췌] 프로그래밍의 정석 3.16 관심의 분리
>> 관심이란 소프트웨어의 기능이나 목적을 뜻한다. 관심을 분리한다는 것은 각각의 관심에 관련된 코드를 모아 독립된 모듈로 만들어 다른 코드로부터 분리한다는 뜻이다.
>> 설계 기법에서 패턴의 대부분은 관심의 분리를 실현하려는 목표를 가지고 있다. 가장 대표 적인 패턴이 MVC 패턴이다. MVC 패턴에서는 비즈니스 로직, 사용자에 대한 표시, 입력 처리를 분리한다.

구조적인 설계 단계로 코드의 역할 분리를 위한 구조를 수립하고, 수립한 결과를 폴더를 통해 표현하는 단계이다.

### 설계 방법
설계는 원칙을 세우는 것이 중요하다. 원칙을 세우는 것 중 하나는 패러다임에서 얻을 수 있다.
클릭 아키텍처에서 패러다임을 무엇을 해야 하나 보다는 무엇을 하지 말아야 하는 지를 알려준다라고 했다.

함수형과 객체지향 패러다임을 따르고 있다.
함수형은 가변을 멀리하고 불변을 추구한다.
객체지향은 제어흐름과 의존성을 같은 방향으로 흐르게 하지 말고
인터페이스를 통한 의존성 역전을 통해 제어흐름과 의존성 방향을 역전 시킨다.

중복을 제거하기전에 중복 요소를 추출하여 담을 수 있는 공간이 필요하다. 중복적인 요소를 해결하는 방법은 이런 방법들이 있다.

```
- 숫자, 문자, 옵션값의 중복 : 상수
- 로직의 중복 : 함수
- 로직과 상태의 중복 : 클래스
- 뷰와 데이터 로직의 중복 : 컴포넌트
- 컴포넌트의 기능 재사용 : 믹스인
- DOM의 조작 중복 : 디렉티브
- 어떤 값의 형태를 바꿀 때 사용하는 템플릿 요소 : 파이프(탬플릿 내에서)
```

이런 중복 해결을 위해 체크리스트가 필요하다.

#### 아키텍처 체크리스트
```
- 컴파일되지 않은 에셋들을 포함하는 구성요소가 있는가?
- 정적 파일들을 포함하는 구성요소가 있는가?
- 페이지나 컴포넌트에 접근하기 전에 실행할 사용자 정의함수를 정의하는 구성요소가 있는가?
- 테스트 파일들을 포함하는 구성요소가 있는가?
- 라우터를 정의하는 구성요소가 있는가?
- 상태관리를 하는 구성요소가 있는가?
- 외부 라이브러리를 애플리케이션에 사용하도록 연결하는 구성요소가 있는가?
- 상수를 정의하는 구성요소가 있는가?
- 컴포넌트를 포함하는 구성요소가 있는가?
- 컴포넌트 볼륨을 줄일 수 있는 구성요소가 있는가?
- 페이지 단위를 분리할 수 있는 구성요소가 있는가?
- 프로젝트 환경 설정을 포함하는 구성요소가 있는가?
```

Angular와 Nuxt의 아키텍처를 빌딩한 사례이다. 기본적으로 Angular와 Nuxt에서 제공한 기능들이 있다. 하지만 미흡한 부분은 추가적으로 추가작업을 진행했다.

##### Angular 사례
```
├─ e2e
│  └─ src
├─ src
│  ├─ app
│  │  ├─ app.module.ts
│  │  ├─ constants
│  │  ├─ modules
│  │  │  └─ feature
│  │  │     ├─ feature.module.ts
│  │  │     ├─ feature.page.ts
│  │  │     ├─ feature.page.html
│  │  │     ├─ pipes
│  │  │     ├─ directives
│  │  │     ├─ shared
│  │  │     │  ├─ feature.helper.ts
│  │  │     │  ├─ feature.state.ts
│  │  │     │  └─ child.state.ts
│  │  │     └─ components
│  │  │        ├─ child.ts
│  │  │        ├─ child.html
│  │  │        ├─ child2
│  │  │        ├─ child2.spec.ts
│  │  │        ├─ child2.ts
│  │  │        └─ child2.html
│  │  ├─ core
│  │  │  ├─ core.module.ts
│  │  │  ├─ apis
│  │  │  ├─ guards
│  │  │  ├─ helpers
│  │  │  └─ states
│  │  └─ shared
│  │     ├─ shared.module.ts
│  │     ├─ components
│  │     ├─ directives
│  │     └─ pipes
│  ├─ assets
│  └─ environments
```
```
- [assets] 컴파일되지 않은 에셋들을 포함하는 구성요소가 있는가?
- [assets] 정적 파일들을 포함하는 구성요소가 있는가?
- [guards] 페이지나 컴포넌트에 접근하기 전에 실행할 사용자 정의함수를 정의하는 구성요소가 있는가?
- [e2e/src, *.spec.ts] 테스트 파일들을 포함하는 구성요소가 있는가?
- [app.routing.ts] 라우터를 정의하는 구성요소가 있는가?
- [states, *.state.ts] 상태관리를 하는 구성요소가 있는가?
- [*.helper.ts] 외부 라이브러리를 애플리케이션에 사용하도록 연결하는 구성요소가 있는가?
- [constants] 상수를 정의하는 구성요소가 있는가?
- [shared/components, modules] 컴포넌트를 포함하는 구성요소가 있는가?
- [helper, pipe, directive] 컴포넌트 볼륨을 줄일 수 있는 구성요소가 있는가?
- [feature.module.ts] 페이지 단위를 분리할 수 있는 구성요소가 있는가?
- [src/enviroments] 프로젝트 환경 설정을 포함하는 구성요소가 있는가?
```

##### Nuxt 사례
```
├─ nuxt.config.ts
├─ assets
├─ components
├─ constants
├─ directives
├─ filters
├─ layouts
├─ middleware
├─ pages
├─ plugins
├─ static
├─ store
└─ test
```

```
- [assets] 컴파일되지 않은 에셋들을 포함하는 구성요소가 있는가?
- [static] 정적 파일들을 포함하는 구성요소가 있는가?
- [middleware] 페이지나 컴포넌트에 접근하기 전에 실행할 사용자 정의함수를 정의하는 구성요소가 있는가?
- [test] 테스트 파일들을 포함하는 구성요소가 있는가?
- [pages, Auto Routing] 라우터를 정의하는 구성요소가 있는가?
- [store] 상태관리를 하는 구성요소가 있는가?
- [plugins] 외부 라이브러리를 애플리케이션에 사용하도록 연결하는 구성요소가 있는가?
- [constants] 상수를 정의하는 구성요소가 있는가?
- [components] 컴포넌트를 포함하는 구성요소가 있는가?
- [directives, filters] 컴포넌트 볼륨을 줄일 수 있는 구성요소가 있는가?
- [pages] 페이지 단위를 분리할 수 있는 구성요소가 있는가?
- [nuxt.config.ts 프로젝트 환경 설정을 포함하는 구성요소가 있는가?
```

### 도구 선택
#### Nuxt Framework
##### Vue 선택 이유
- 적시에 개발완료하기 위해서
- 러닝커브가 적고 익숙함으로 Vue 선택

##### Vue 라이브러리 조합과 Nuxt 중 Nuxt 선택 이유
- Vue 라이브러리 조합 시, 조합에 대한 비용과 문서화에 비용이듬
- Nuxt 선택 시, 이미 조합이 되어 있고 문서화가 비용이 최소화됨

##### 장점으로 보는 것
- 폴더 구조와 아키텍처는 셋업되어 있으므로 비즈니스 코드에 집중할 수 있음

#### TypeScript
- TypeScript를 사용하는 장점과 동일
- 타입의 추측, 자료구조를 추측할 필요없음
- 코드에 타입과 자료 구조의 형태를 작성하여 추측할 필요 없음

#### SPA
- [보완] 초기 렌딩 후 필요한 부분만 변경이 가해짐으로 깜빡임 없이 매끄러운 UI 제공
- 검색 엔진을 대응할 필요 없음
- 추후에 필요하면 Static Generated로 대응 가능