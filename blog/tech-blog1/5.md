## 벽돌 조립 가이드 라인
### 서론

저는 구현할 때 작은 문제 또는 쉬운 문제부터 구현합니다. 작거나 쉬운 문제은 많은 고민이 없거나 경험했던 사항이라 쉽게 구현 가능합니다. 하지만 크고 어려운 문제은 많은 고민이 필요하고 생소한 부분입니다. 그래서 구현이 필요한 내용이 있으면 빠르게 해결할 수 있는 문제부터 해결하고, 시간이 필요한 문제을 나중에 하여 효율적인 판단을 하기 위해 고민할 시간을 충분히 가집니다.

이 글에서는 구현할 때 참고할 가이드 라인을 제시합니다. 사람마다 규모를 측정하는 범위가 다르고 쉽다고 느끼는 부분이 다르기 때문에 구체적인 예시 보다는 추상적인 가이드 라인을 제시합니다.

### 정보

#### 작은 문제 또는 쉬운 문제부터 개발

> 작은 소프트웨어는 단순하고 다루기 쉬우며 큰 소프트웨어보다 훨씬 뛰어나다. 따라서 소프트웨어는 작게 만들고 작게 유지하도록 한다.
> 작은 소프트웨어는 다음과 같은 장점이 있다.
>
> - 이해가 쉽다
>
> - 보수가 쉽다
>
> - 다른 소프트웨어와 조합하기 쉽다
>
> 반면에 큰 소프트웨어는 다음과 같은 문제가 있다.
>
> - 복잡하고 코드를 이해하기 어렵다
>
> - 예측하지 못하고 사태에 대응할 수 없다
>
>   
>
> - 우에다 이사오. 『프로그래밍의 정석』. 류두진(역). 프리렉, 2017.

작은 문제을 개발하는 것은 단순하고 다루기 쉽습니다. 단순할 수록 이해가 쉽고, 보수가 쉽고, 다른 부분과 조합하기 쉽습니다.

반면에 큰 문제을 개발하는 것은 작은 문제을 개발하는 것보다 어려우며 작은 문제과 비교적 이러한 단점을 가지고 있습니다. 큰 문제을 개발하는 것은 복잡하고 코드를 이해하기 어렵습니다. 그리고 예측하지 못하고 사태에 대응하기 힘듭니다.

그렇다면 큰 문제은 어떻게 해결해야 할까요?

> 커다란 문제를 그 자체로 해결하려면 어려워지고 시간이 많이 걸린다. 최악의 경우 해결할 수 없을 때도 있다. 규모가 너무 큰 탓에 문제가 너무 복잡하기 때문이다. 제어하기 쉬운 규모까지 문제를 분할하고 거기서부터 착수하는 방식이 효율적이다.
>
> - 우에다 이사오. 『프로그래밍의 정석』. 류두진(역). 프리렉, 2017.

분할 정복을 통해서 해결할 수 있습니다. 큰 문제를 작은 문제로 쪼개고 작은 문제를 해결하면 자연스럽게 큰 문제도 해결하기 쉬워집니다. 

#### 한 번에 하나의 작업만 한다.

> 가장 좋은 소프트웨어란 생애 중에 단 하나의 작업만을 제대로 완수하는 소프트웨어다. 하나의 작업에 집중함으로써 코드에 불필요한 부분을 없앨 수 있다. 하나의 작업에 집중함으로써 해당 작업의 본질을 파악할 수 있다. 하나의 작업을 제대로 하는 소프트웨어를 만들 수 없다면 문제를 아직 완전하게 이해하지 못했다는 뜻이다.
>
> - 우에다 이사오. 『프로그래밍의 정석』. 류두진(역). 프리렉, 2017.

#### 조금씩 개발한다.

> 프로그래밍은 한 번에 작은 하나만을 수행한다. 작지만 확실한 한 걸음을 반복해서 나아가야 결과적으로 품질도 시간 효츌도 높아진다. 왜냐하면 한 번에 여러 가지를 작업하면 작업에 혼선을 빚어 모두 실패할 가능성이 커지기 때문이다. 한 걸음씩 나아가면 마지막 한 걸음을 되돌리기가 편하다.
>
> - 우에다 이사오. 『프로그래밍의 정석』. 류두진(역). 프리렉, 2017.

#### 개발 원칙

제가 선호하는 개발 원칙 다섯가지에 대해 소개 드릴려고 합니다. 아무리 좋은 기술이나 설계가 있어도 정도(程度)를 지키는 게 중요하다고 생각합니다. 이 다섯가지 원칙들은 개발의 정도(程度)를 지키는 데 많은 도움이 되었습니다.

##### KISS(Keep It Short and Simple)

코드를 작성할 때는 최우선 가치를 단순성과 간결성에 둔다. 복잡한 코드는 읽기 어렵고 수정하기 어려워진다. 프로그래밍 중에도 코드가 동작할 수 있는 가장 간단한 방법은 무엇인지 항상 질문을 던져야 한다.

##### DRY(Don't Repeat Yourself)

똑같은 코드가 여러 군데 있으면 모든 곳을 정확하게 수정하지 않는 이상 전체적으로 정합성을 보장할 수 없다. 코드 로직은 함수화, 모듈화하고, 데이터라면 이름을 붙여 상수를 정의한다.
디자인 패턴은 같은 문제에 관해 몇 번씩 반복해서 해결책을 생각하는 사고의 중복이 일어나지 않게 하는 기법이라고도 할 수 있다.

##### YAGNI(You Aren't Going to Need it)

확장성을 고려해서 넣은 설계라도 예상은 대부분 빗나간다. 빗나간다는 것은 거기에 들인 시간이 쓸모없어진다는 뜻이다. 범용성보다는 단순성을 생각하자. 범용성이 가져다주는 재사용성이나 확작성도 좋지만, 그 보다는 우선 사용할 수 있는 데 가치를 두자. 

##### SLAP(Single Level of Abstraction Principle)

코드를 작성할 때 높은 수준의 추상화 개념과 낮은 수준의 추상화 개념을 분리하도록 한다. 추상화 단계는 상하가 아니라 기능의 복잡도에 따라 여러 계층으로 분리한다. 결과적으로 추상화 수준을 일치시킨 코드는 훌륭한 책과 같다. 최고 수준부터 중간 수준의 처리가 책의 '목차'가 되고 최저 수준의 처리가 책의 '본문 내용'이 된다.

##### 명명이 중요하다(Naming is important)

적절한 이름을 붙일 수 있었다는 것은 해당 요소가 바르게 이해되고 바르게 설계되어 있다는 뜻이다. 반대로 어울리지 않는 이름을 붙여졌다는 것은 해당 요소가 달성해야 할 역할에 대해 프로그래머 자신이 충분히 이해하지 못했다는 뜻이다.
이름은 코드를 통해 프로그래머끼리 의사소통을 이루어지므로 이름이 적절하지 않으면 코드상의 대화는 성립하지 않는다.

### 정리