## 벽돌 정하기
### 개요 
### 배경 
### 주장 
### 근거 
### 사례

> [도서 발췌] 클린 아키텍처

> 모든 프로그램은 순차 / 분기 / 반복이라는 세 가지 구조만으로도 표현할 수 있다.

컴퓨터 프로그램은 순차, 분기, 반복으로 이루어져있고, 비교 연산, 자료 구조 분해 및 할당과 같은 자주 사용하는 요소들이 존재한다. 이 과정은 구현 방법이 다양함으로 룰을 정할 필요가 있다.

#### 순차
- 비동기는 `async` 함수 사용하여 동기식으로 기술한다.
- 에러 처리가 필요할 때, `then`, `catch`를 사용한다.

#### 분기
- `if/else`는 삼항 연산자로 대체
  - 참고 포스트: [삼항연산자의 멋짐을 모르는 당신이 불쌍해](https://tpgns.github.io/2018/04/24/nested-ternaries-are-great/)
- `!`는 `not` 함수 사용
  - `!value` => `not(value)`
- `!!`는 `toBool` 함수 사용
  - `!!value` => `toBool(value)`

#### 반복
- 코드에 `Array.prototype.map`, `Array.prototype.filter`를 활용하는 패턴이 보임
- `map`, `filter` 함수 사용하여 함수 조합을 높게 해야함

#### 비교 연산
- 코드에서 동일한 타입의 값을 비교하는 패턴이 보임
  - `===`을 사용함
- `isSame(src, target): boolean` 형태로 대체

#### 자료 구조 분해 및 할당
- 분해는 `pick`, `pluck` 함수 활용
- 할당은 `assign` 함수 사용

```js
const obj = {key1: 'value1', key2: 'value2'}
pick(['key1'], obj) // { key1: 'value1' }
pluck(['key1'], obj) // ['value1']

assign({}, {key3: 'value3'}, obj)
// {key1: 'value1', key2: 'value2', key3: 'value3'}
```

#### 선언형 함수 사용
자바스크립트 문법을 통해 작성한 기능들에 이름을 부여한 함수이다. 콜백 함수나 Array와 Object를 다루는 함수는 선언형 함수로 대체할 수 있는 기능들이 많다.

선언형으로 작성할 경우 상태와 로직을 작성해야 하지만 단어 하나의 함수로 설명이 가능하다. ES버전에 국한되지 않고 선언이 가능한 방법론이다.

참고: https://chodragon9.github.io/blog/declarative-function/

#### TMI: 개발 원칙
> [도서 발췌] 프로그래밍 정석 2. 원칙: 프로그래밍의 가이드라인
>> 2.1 KISS(Keep It Simple, Stupid / Keep It Short and Simple)
>>> 코드를 작성할 때는 최우선 가치를 단순성과 간결성에 둔다. 복잡한 코드는 읽기 어렵고 수정하기 어려워진다. 프로그래밍 중에도 코드가 동작할 수 있는 가장 간단한 방법은 무엇인지 항상 질문을 던져야 한다.
>> 2.2 DRY(Don't Repeat Yourself)
>>> 똑같은 코드가 여러 군데 있으면 모든 곳을 정확하게 수정하지 않는 이상 전체적으로 정합성을 보장할 수 없다. 코드 로직은 함수화, 모듈화하고, 데이터라면 이름을 붙여 상수를 정의한다.
>>> 디자인 패턴은 같은 문제에 관해 몇 번씩 반복해서 해결책을 생각하는 사고의 중복이 일어나지 않게 하는 기법이라고도 할 수 있다.
>> 2.3 YAGNI(You Aren't Going to Need it)
>>> 확장성을 고려해서 넣은 설계라도 예상은 대부분 빗나간다. 빗나간다는 것은 거기에 들인 시간이 쓸모없어진다는 뜻이다. 범용성보다는 단순성을 생각하자. 범용성이 가져다주는 재사용성이나 확작성도 좋지만, 그 보다는 우선 사용할 수 있는 데 가치를 두자. 
>> 2.5 SLAP(Single Level of Abstraction Principle)
>>> 코드를 작성할 때 높은 수준의 추상화 개념과 낮은 수준의 추상화 개념을 분리하도록 한다. 추상화 단계는 상하가 아니라 기능의 복잡도에 따라 여러 계층으로 분리한다. 결과적으로 추상화 수준을 일치시킨 코드는 훌륭한 책과 같다. 최고 수준부터 중간 수준의 처리가 책의 '목차'가 되고 최저 수준의 처리가 책의 '본문 내용'이 된다.
>> 2.7 명명이 중요하다(Naming is important)
>>> 적절한 이름을 붙일 수 있었다는 것은 해당 요소가 바르게 이해되고 바르게 설계되어 있다는 뜻이다. 반대로 어울리지 않는 이름을 붙여졌다는 것은 해당 요소가 달성해야 할 역할에 대해 프로그래머 자신이 충분히 이해하지 못했다는 뜻이다.
>>> 이름은 코드를 통해 프로그래머끼리 의사소통을 이루어지므로 이름이 적절하지 않으면 코드상의 대화는 성립하지 않는다.
